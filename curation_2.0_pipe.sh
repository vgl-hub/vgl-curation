#!/bin/sh 

Help()
{
    # Display help

    printf "\nCommand: sh curation_2.0_pipe.sh -f <original fasta> -a <agp> <options>\n\n"
    echo "-h Prints help."
    echo "-f Pass original fasta file with combined haplotypes."
    echo "-a Pass the agp generated by PretextView."
    # echo "-p Pass the primary assembly you curated (1 for haplotype 1 (default), 2 for haplotype 2)."
    printf "\n"
}

fasta=""
agpfile=""
hap=""

while getopts ":hf:a:p:" option; do
    case $option in 
        h) #display Help
            Help
            exit;;
        f) #Pass original fasta file 
            fasta=$OPTARG;;
        a) #Pass Pretext generated AGP file of curated assembly
            agpfile=$OPTARG;;
    esac
done

if [ -d logs ]
then
    count=`ls logs/* | wc -l`
    exec 1<> logs/std.${count}.out
else 
    mkdir -p logs 
    exec 1<> logs/std.0.out
    count=0
fi 

pth=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
printf "Rapid-curation-2.0 scripts located in: $pth\n"

## Programs/tools
# use_gfastats=/vggpfs/fs3/vgl/store/nbrajuka/gfastats/build/bin/gfastats
# use_seqkit=/vggpfs/fs3/vgl/store/nbrajuka/conda/envs/statistics/bin/seqkit
printf "Dependecies:\nBiopython\npandas\ngfastats\nmashmap\nnatsort\nrb_sysopen" 

# could reasonably put everything in a function and just call for both haps. 


printf "\nOriginal assembly: ${fasta} \nPretextView generated AGP: ${agpfile}\n\n" ### but checks/breakpoints for if these aren't provided.

printf "Running AGPcorrect on the PretextView generated agp to correct for sequence lengths.\n" 
printf "python3 ${pth}/AGPcorrect.py ${fasta} ${agpfile}\n\n"
python3 $pth/AGPcorrect.py ${fasta} ${agpfile} > corrected.agp

printf "Splitting the haplotypes from the corrected AGP. Outputs sent to respective directories.\n"
printf "python3 $pth/hap_split.py -1 Hap_1/hap.agp -2 Hap_2/hap.agp -a corrected.agp\n\n"
python3 $pth/hap_split.py  -1 Hap_1/hap.agp -2 Hap_2/hap.agp -a corrected.agp 

printf "Assigning unlocs before the agp is imposed on the fasta.\n"
## If the --agp-to-path in the next block is run first the unlocs will get assimilated into their main assigned scaffolds - they need to be differentiated first.
printf "python3 $pth/unloc.py -a Hap_1/hap.agp -o Hap_1 \n\n" 
printf "python3 $pth/unloc.py -a Hap_2/hap.agp -o Hap_2 \n\n"
python3 $pth/unloc.py -a Hap_1/hap.agp -o Hap_1
python3 $pth/unloc.py -a Hap_2/hap.agp -o Hap_2

printf "Imposing the haplotypic agp on the original fasta to generate a curated fasta.\n"
printf "gfastats $fasta --agp-to-path Hap_1/hap.unlocs.no_hapdups.agp --sort largest -o Hap_1/hap.sorted.fa\n"
gfastats $fasta --agp-to-path Hap_1/hap.unlocs.no_hapdups.agp -o Hap_1/hap.unlocs.no_hapdups.fa 2>> logs/std.${count}.out 

printf "gfastats $fasta --agp-to-path Hap_1/hap.unlocs.no_hapdups.agp --sort largest -o Hap_2/hap.sorted.fa\n\n"
gfastats $fasta --agp-to-path Hap_2/hap.unlocs.no_hapdups.agp -o Hap_2/hap.unlocs.no_hapdups.fa 2>> logs/std.${count}.out 

printf "gfastats Hap_1/hap.unloc.no_hapdups.fa --sort largest -o Hap_1/hap.sorted.fa"
gfastats Hap_1/hap.unlocs.no_hapdups.fa --sort largest -o Hap_1/hap.sorted.fa 2>> logs/std.${count}.out

printf "gfastats Hap_2/hap.unloc.no_hapdups.fa --sort largest -o Hap_2/hap.sorted.fa"
gfastats Hap_2/hap.unlocs.no_hapdups.fa --sort largest -o Hap_2/hap.sorted.fa 2>> logs/std.${count}.out 

printf "\nSubstituting scaffold for chromosome assignments.\n"
printf "python3 $pth/chromosome_assignment.py -a Hap_1/hap.unlocs.no_hapdups.agp -f Hap_1/hap1_sorted.fasta -o Hap_1 \n\n"
python3 $pth/chromosome_assignment.py -a Hap_1/hap.unlocs.no_hapdups.agp -f Hap_1/hap.sorted.fa -o Hap_1

printf "python3 $pth/chromosome_assignment.py -a Hap_2/hap.unlocs.no_hapdups.agp -f Hap_2/hap2_sorted.fasta -o Hap_2\n\n"
python3 $pth/chromosome_assignment.py -a Hap_2/hap.unlocs.no_hapdups.agp -f Hap_2/hap.sorted.fa -o Hap_2



printf "mashmap -r Hap_1/hap.chr_level.fa  -q Hap_2/hap.chr_level.fa -f one-to-one -t 16 -s 50000 --pi 90 \n\n"
mashmap -r Hap_1/hap.chr_level.fa  -q Hap_2/hap.chr_level.fa -f one-to-one -t 16 -s 50000 --pi 90  2>> logs/std.${count}.out 



printf "Process Mashmap output for reorientation and renaming \n\n"


### Block 1 : Use if AGP file has not been tagged with Micro1 and Micro2 tags

cut -f1 mashmap.out | grep -v SCAFFOLD | grep -v unloc | uniq > tmp

while read id; do
  awk -v val="$id" '$1 == val' mashmap.out |
  awk '{print $0 "\t" $9 - $8}' |
  sort -nrk11 |
  head -n1
done < tmp | awk -F" " '/^SUPER_[0-9]+/ {print $1, $5, $6}' > orientation.tmp

printf "Preparing reverse complement instructions..."
awk -F" " -v OFS="\t" '$2=="-" {print "RVCP",$1}' orientation.tmp > rvcp.sak

printf "gfastats Hap_2/hap2_sorted.fasta  -k rvcp.sak  -o Hap_2/hap2.reoriented.fasta \n\n"
gfastats Hap_2/hap2_sorted.fasta  -k rvcp.sak  -o Hap_2/hap2.reoriented.fasta
awk '{print $1 "\t" $3}' orientation.tmp > hap2.vs.hap1.tsv

printf "ruby $pth/update_mapping.rb -f Hap_2/hap2.reoriented.fasta -t hap2.vs.hap1.tsv >  Hap_2/hap2.reoriented.renamed.fasta \n\n"
ruby $pth/update_mapping.rb -f Hap_2/hap2.reoriented.fasta -t hap2.vs.hap1.tsv >  Hap_2/hap2.reoriented.renamed.fasta


### End Block 1

### Block 2 : Use if AGP file has been tagged with Micro1 and Micro2 tags

#printf "python3 $pth/filter_mashmap_with_tagged_pairs.py  -1 Hap\n\n"
#python3 $pth/filter_mashmap_with_tagged_pairs.py  -1 Hap_1/inter_chr.tsv -2 Hap_2/inter_chr.tsv -r Hap_1 -q Hap_2 -a corrected.agp -m mashmap.out -o tagged_pairs/
#printf "gfastats Hap_2/hap2_sorted.fasta  -k tagged_pairs/rvcp.sak  -o Hap_2/hap2.reoriented.fasta \n\n"
#gfastats Hap_2/hap2_sorted.fasta  -k tagged_pairs/rvcp.sak  -o Hap_2/hap2.reoriented.fasta
#printf "ruby $pth/update_mapping.rb -f Hap_2/hap2.reoriented.fasta -t tagged_pairs/hap2.vs.hap1.tsv >  Hap_2/hap2.reoriented.renamed.fasta \n\n"
#ruby $pth/update_mapping.rb -f Hap_2/hap2.reoriented.fasta -t tagged_pairs/hap2.vs.hap1.tsv >  Hap_2/hap2.reoriented.renamed.fasta

### End Block 2

exec 1>&-

